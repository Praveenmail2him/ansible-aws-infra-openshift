---

########
# Create the route tables for each subnet
########

## Create ingress subnet route table and assign to subnets

- name: Clear variable
  set_fact:
    newRTBs: []

- name: Find subnets for ingress routes tables
  set_fact:
    newRTBs: "{{newRTBs | default([]) + [{ 'Subnet_id':item.subnet_id }]}}"
  loop: "{{subnetDict}}"
  when: '"ingress" in item.Name'

- name: Create list of ingress route tables to be created
  set_fact:
    ingressRTBs: "{{ ingressRTBs | default([]) + [{ 'Name':name, 'Subnet_id':item.Subnet_id }] }}"
  loop: "{{newRTBs}}"
  loop_control:
    index_var: idx
  vars:
    name: "{{resourceGroup|lower}}-{{edge|lower}}-ingress-rtb-{{idx|string}}"

- name: Query AWS for existence of ingress route tables
  amazon.aws.ec2_vpc_route_table_info:
    filters:
      vpc-id: "{{ edgeVpc.id }}"
      "tag:Name": "{{item.Name}}"
    profile: "{{awsProfile}}"
    region: "{{awsRegion}}"
  loop: "{{ingressRTBs}}"
  register: infoReturned

- name: Clear variable
  set_fact:
    newRTBs: []

- name: Parse return from query for existence of ingress route tables
  set_fact:
    newRTBs: "{{ newRTBs | default([]) + [{ 'Name':item.Name, 'Subnet_id':item.Subnet_id, 'Exists':True }] }}"
  when: infoReturned.results[idx].route_tables | length > 0
  loop: "{{ingressRTBs}}"
  loop_control:
    index_var: idx

- name: Parse return from query for non-existence of ingress route tables
  set_fact:
    newRTBs: "{{ newRTBs | default([]) + [{ 'Name':item.Name, 'Subnet_id':item.Subnet_id, 'Exists':False }] }}"
  when: infoReturned.results[idx].route_tables | length == 0
  loop: "{{ingressRTBs}}"
  loop_control:
    index_var: idx

- name: Create new list with parse results
  set_fact:
    ingressRTBs: "{{newRTBs}}"

- name: Create ingress route table if it does not exist
  amazon.aws.ec2_vpc_route_table:
    vpc_id: "{{ edgeVpc.id }}"
    region: "{{ awsRegion }}"
    profile: "{{ awsProfile }}"
    tags:
      Name: "{{item.Name}}"
    subnets: "{{ item.Subnet_id }}"
    routes:
      - dest: "{{ aclSubnets[0] }}"  # Ingress i.e. local traffic
        gateway_id: 'local'
      - dest: "{{ aclSubnets[1]}}"   # Bastion
        gateway_id: 'local'
      - dest: '0.0.0.0/0'
        gateway_id: "{{ edgeVpc.igw_id }}"
  when: not item.Exists
  loop: "{{ingressRTBs}}"

## Create bastion subnet route table and assign to subnets

- name: Clear variables
  set_fact:
    newRTBs: []

- name: Find subnets for bastion routes tables
  set_fact:
    newRTBs: "{{newRTBs | default([]) + [{ 'Subnet_id':item.subnet_id }]}}"
  loop: "{{subnetDict}}"
  when: '"bastion" in item.Name'

- name: Create list of bastion route tables to be created
  set_fact:
    bastionRTBs: "{{ bastionRTBs | default([]) + [{ 'Name': name, 'Subnet_id':item.Subnet_id }] }}"
  loop: "{{newRTBs}}"
  loop_control:
    index_var: idx
  vars:
    name: "{{resourceGroup|lower}}-{{edge|lower}}-bastion-rtb-{{idx|string}}"

- name: Query AWS for existence of bastion route tables
  amazon.aws.ec2_vpc_route_table_info:
    filters:
      vpc-id: "{{ edgeVpc.id }}"
      "tag:Name": "{{item.Name}}"
    profile: "{{awsProfile}}"
    region: "{{awsRegion}}"
  loop: "{{bastionRTBs}}"
  register: infoReturned

- name: Clear variables
  set_fact:
    newRTBs: []

- name: Parse return from query for existence of ingress route tables
  set_fact:
    newRTBs: "{{ newRTBs | default([]) + [{ 'Name':item.Name, 'Subnet_id':item.Subnet_id, 'Exists':True }] }}"
  when: infoReturned.results[idx].route_tables | length > 0
  loop: "{{bastionRTBs}}"
  loop_control:
    index_var: idx

- name: Parse return from query for non-existence of ingress route tables
  set_fact:
    newRTBs: "{{ newRTBs | default([]) + [{ 'Name':item.Name, 'Subnet_id':item.Subnet_id, 'Exists':False }] }}"
  when: infoReturned.results[idx].route_tables | length == 0
  loop: "{{bastionRTBs}}"
  loop_control:
    index_var: idx

- name: Replace existing list with new list
  set_fact:
    bastionRTBs: "{{newRTBs}}"

- name: Create bastion route table if it does not exist
  amazon.aws.ec2_vpc_route_table:
    vpc_id: "{{ edgeVpc.id }}"
    region: "{{ awsRegion }}"
    profile: "{{ awsProfile }}"
    tags:
      Name: "{{item.Name}}"
    subnets: "{{ item.Subnet_id }}"
    routes:
      - dest: "{{ aclSubnets[0] }}"  # Ingress for return connections
        gateway_id: 'local'
      - dest: "{{ aclSubnets[1]}}"   # Bastion i.e. local traffic
        gateway_id: 'local'
  when: not item.Exists
  loop: "{{bastionRTBs}}"

## Create egress subnet route table and assign to subnets

- name: Build list of egress routes from NAT Gateway list
  set_fact:
    egressRTBs: "{{egressRTBs | default ([]) + [{ 'Name':resourceGroup|lower + '-' + edge|lower + '-egress-rtb-' + idx|string, 'Subnet_id':item.Subnet_id, 'NAT_GW_id':item.NAT_GW_id }] }}"
  loop: "{{ natGWDict }}"
  loop_control:
    index_var: idx

- name: Query AWS for existence of egress route tables
  amazon.aws.ec2_vpc_route_table_info:
    filters:
      vpc-id: "{{ edgeVpc.id }}"
      "tag:Name": "{{item.Name}}"
    profile: "{{awsProfile}}"
    region: "{{awsRegion}}"
  loop: "{{egressRTBs}}"
  register: infoReturned

- name: Parse return from query for existence of route tables
  set_fact:
    newList: "{{ newList | default([]) + [{'Name':item.Name,'Subnet_id':item.Subnet_id, 'NAT_GW_id':item.NAT_GW_id,'Exists':True}] }}"
  when: infoReturned.results[idx].route_tables | length > 0
  loop: "{{egressRTBs}}"
  loop_control:
    index_var: idx

- name: Parse return from query for non-existence of route tables
  set_fact:
    newList: "{{ newList | default([]) + [{'Name':item.Name,'Subnet_id':item.Subnet_id, 'NAT_GW_id':item.NAT_GW_id,'Exists':False}] }}"
  when: infoReturned.results[idx].route_tables | length == 0
  loop: "{{egressRTBs}}"
  loop_control:
    index_var: idx

- name: Replace existing list with new one that includes status
  set_fact:
    egressRTBs: "{{newList}}"

- name: Create egress route table for each subnet with each NAT Gateway
  amazon.aws.ec2_vpc_route_table:
    vpc_id: "{{ edgeVpc.id }}"
    region: "{{ awsRegion }}"
    profile: "{{ awsProfile }}"
    tags:
      Name: "{{item.Name}}"
    subnets: "{{ item.Subnet_id }}"
    routes:
#      - dest: "{{ management_cidr }}"  # VPC for return connections
#        gateway_id: 'local'     # This needs to be modified to the VPC Peer Connection when it is available
#      - dest: "{{ workload_cidr }}"  # VPC for return connections
#        gateway_id: 'local'     # This needs to be modified to the VPC Peer Connection when it is available
      - dest: "{{ aclSubnets[2]}}"   # Egress i.e. local traffic
        gateway_id: 'local'
      - dest: '0.0.0.0/0'
        gateway_id: "{{ item.NAT_GW_id }}"   # Needs debugging - gives an error that this is an invalid id
  when: not item.Exists
  loop: "{{ egressRTBs }}"
